// crtz_native_compiler.cpp
// Native code compiler for CRTZ scripts

#include <iostream>
#include <vector>
#include <string>
#include <variant>
#include <unordered_map>
#include <cstdint>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <utility>
#include <cstdio>
#include <iterator>
#include <stdexcept>
#include <cstdlib>
#include <filesystem>
using namespace std;
namespace fs = std::filesystem;

// -------------------- Parser --------------------
struct LineIR { string text; };
struct ChoiceIR { string text; string targetNode; };
struct NodeIR {
    string name;
    vector<LineIR> lines;
    vector<ChoiceIR> choices;
    string gotoNode;
};
struct ProgramIR {
    vector<NodeIR> nodes;
    string entry = "Start";
};

inline void strip_semicolon(string& s){ if(!s.empty() && s.back()==';') s.pop_back(); }

ProgramIR parse_crtz(const string& text){
    ProgramIR ir;
    ir.entry = "Start";
    istringstream in(text);
    string token;
    NodeIR* cur = nullptr;

    while(in >> token){
        if(token=="node"){
            string nodeName; in >> nodeName;
            // consume '{'
            char ch; in >> ch; if(ch!='{'){ while(in.get(ch) && ch!='{'); }
            ir.nodes.emplace_back();
            cur = &ir.nodes.back();
            cur->name = nodeName;
            if(ir.entry.empty()) ir.entry = nodeName;
        } else if(cur){
            if(token=="line"){
                char ch; in >> ws; in.get(ch);
                if(ch!='"') { /* skip malformed */ continue; }
                string s; getline(in, s, '"');
                cur->lines.push_back({s});
                // consume trailing ;
                in >> ws; if(in.peek()==';') in.get();
            } else if(token=="choice"){
                string idcolon; in >> idcolon; // e.g. 1:
                char ch; in >> ws; in.get(ch);
                if(ch!='"') continue;
                string s; getline(in,s,'"');
                string arrow; in >> arrow; // ->
                string target; in >> target; strip_semicolon(target);
                cur->choices.push_back({s, target});
            } else if(token=="goto"){
                string target; in >> target; strip_semicolon(target);
                cur->gotoNode = target;
            } else if(token=="}"){
                cur = nullptr;
            } else {
                // ignore other tokens for now (variables, npc, desc, etc.)
                // consume until ';' maybe
                if(in.peek()==';') { char c; in.get(c); }
            }
        } else {
            // top-level token not in node: maybe global var or header, ignore for now
            // consume until end of line or ';'
            if(in.peek()!='\n' && in.peek()!=EOF){
                // attempt to skip remainder of token line if semicolon present
                // naive: if next char isn't '{' or '"', just continue
            }
        }
    }

    return ir;
}

// -------------------- C++ Code Generator --------------------
string sanitize_identifier(const string& name) {
    string result;
    for (char c : name) {
        if (isalnum(c)) {
            result += c;
        } else {
            result += '_';
        }
    }
    return result;
}

string escape_string(const string& s) {
    string result;
    for (char c : s) {
        if (c == '"' || c == '\\') {
            result += '\\';
        }
        result += c;
    }
    return result;
}

bool generate_cpp_code(const ProgramIR& ir, const string& outPath) {
    ofstream f(outPath);
    if (!f) return false;
    
    // Header
    f << "// Generated by CRTZ Native Compiler\n";
    f << "#include <iostream>\n";
    f << "#include <string>\n";
    f << "#include <vector>\n";
    f << "#include <limits>\n";
    f << "using namespace std;\n\n";
    
    // Forward declarations for all node functions
    for (const auto& node : ir.nodes) {
        f << "void node_" << sanitize_identifier(node.name) << "();\n";
    }
    f << "\n";
    
    // Main function
    f << "int main() {\n";
    f << "    node_" << sanitize_identifier(ir.entry) << "();\n";
    f << "    return 0;\n";
    f << "}\n\n";
    
    // Generate each node function
    for (const auto& node : ir.nodes) {
        f << "void node_" << sanitize_identifier(node.name) << "() {\n";
        
        // Output all lines
        for (const auto& line : node.lines) {
            f << "    cout << \"" << escape_string(line.text) << "\" << endl;\n";
        }
        
        // Handle choices
        if (!node.choices.empty()) {
            f << "    vector<string> choices = {\n";
            for (const auto& choice : node.choices) {
                f << "        \"" << escape_string(choice.text) << "\",\n";
            }
            f << "    };\n";
            f << "    vector<string> targets = {\n";
            for (const auto& choice : node.choices) {
                f << "        \"" << sanitize_identifier(choice.targetNode) << "\",\n";
            }
            f << "    };\n";
            
            f << "    while (true) {\n";
            f << "        cout << \"\\nChoose:\" << endl;\n";
            f << "        for (int i = 0; i < choices.size(); i++) {\n";
            f << "            cout << \"  \" << (i+1) << \") \" << choices[i] << endl;\n";
            f << "        }\n";
            f << "        int selection;\n";
            f << "        cout << \"> \";\n";
            f << "        cin >> selection;\n";
            f << "        if (cin.fail()) {\n";
            f << "            cin.clear();\n";
            f << "            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n";
            f << "            cout << \"Invalid input\" << endl;\n";
            f << "            continue;\n";
            f << "        }\n";
            f << "        if (selection >= 1 && selection <= choices.size()) {\n";
            f << "            string target = targets[selection-1];\n";
            
            // Generate if-else chain for targets
            f << "            if (false) {}\n";
            for (const auto& target_node : ir.nodes) {
                string sanitized = sanitize_identifier(target_node.name);
                f << "            else if (target == \"" << sanitized << "\") {\n";
                f << "                node_" << sanitized << "();\n";
                f << "                return;\n";
                f << "            }\n";
            }
            f << "        } else {\n";
            f << "            cout << \"Invalid selection\" << endl;\n";
            f << "        }\n";
            f << "    }\n";
        }
        // Handle goto
        else if (!node.gotoNode.empty()) {
            f << "    node_" << sanitize_identifier(node.gotoNode) << "();\n";
        }
        
        f << "}\n\n";
    }
    
    f.close();
    return true;
}

bool compile_to_executable(const ProgramIR& ir, const string& outPath) {
    // Create a temporary directory
    string tempDir = fs::temp_directory_path() / "crtz_compile";
    fs::create_directories(tempDir);
    
    // Generate C++ code
    string cppPath = tempDir + "/generated.cpp";
    if (!generate_cpp_code(ir, cppPath)) {
        cerr << "Failed to generate C++ code\n";
        return false;
    }
    
    // Compile with system compiler
    string compileCmd = "g++ -std=c++17 -o \"" + outPath + "\" \"" + cppPath + "\"";
    int result = system(compileCmd.c_str());
    
    // Clean up
    fs::remove_all(tempDir);
    
    return result == 0;
}

// -------------------- CLI --------------------
static void usage(){
    cerr << "Usage:\n"
         << "  crtzc -c input.crtz -o output.exe   # compile to native executable\n"
         << "  crtzc input.crtz                    # compile and run\n";
}

int main(int argc, char** argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    if(argc < 2){ usage(); return 1; }

    string arg1 = argv[1];
    if(arg1=="-c"){
        if(argc < 5){ usage(); return 1; }
        string inPath = argv[2];
        string outFlag = argv[3];
        string outPath = argv[4];
        if(outFlag != "-o"){ usage(); return 1; }
        ifstream f(inPath);
        if(!f){ cerr<<"Cannot open input: "<<inPath<<"\n"; return 1; }
        string src((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
        ProgramIR ir = parse_crtz(src);
        if(!compile_to_executable(ir, outPath)){ 
            cerr<<"Failed to compile to native executable\n"; 
            return 2; 
        }
        cout << "Compiled to native executable: " << outPath << "\n";
        return 0;
    } else {
        // Assume arg1 is a .crtz file to compile and run
        string inPath = arg1;
        ifstream f(inPath);
        if(!f){ cerr<<"Cannot open input: "<<inPath<<"\n"; return 1; }
        string src((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
        ProgramIR ir = parse_crtz(src);
        
        // Create a temporary executable
        string tempExe = fs::temp_directory_path() / "crtz_temp_executable";
        #ifdef _WIN32
        tempExe += ".exe";
        #endif
        
        if(!compile_to_executable(ir, tempExe)){ 
            cerr<<"Failed to compile\n"; 
            return 2; 
        }
        
        // Run the executable
        int result = system(tempExe.c_str());
        
        // Clean up
        fs::remove(tempExe);
        
        return result;
    }
}